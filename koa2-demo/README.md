## 安装了babel-cli之后不能够使用babel-node？
局部安装的需要指出路径，如使用“./node_modules/.bin/babel-node app.js”


## 修改淘宝npm源
`npm i nodemon -D --registry=https://registry.npm.taobao.org`

## 同步异步阻塞非阻塞
[怎样理解同步异步和阻塞非阻塞](https://www.jianshu.com/p/9fa26b0b22a0)
今天跟公司同事讨论了下同步异步，阻塞非阻塞，在这里做下总结，同时也发现很多同学（包括之前我）对同步异步，阻塞非阻塞的概念理解不太清晰。

之前看过一个很形象的例子来说明同步异步阻塞非阻塞。
场景： 小明使用 chrome 下载一个软件。

1. 同步阻塞

小明使用 没有提醒功能的chrome 下载一个软件。小明 一直坐在电脑面前什么事也不做， 等待软件下载完成。
阻塞：小明(调用者) 等待电脑下载完成，什么事也不做(当前进程挂起) 。
同步： 没有提醒功能的 chrome(被调用者)
总结： 调用结果返回前，进程挂起，等待调用结果返回。效率低

2.异步阻塞

小明使用 有提醒功能的chrome(下载完成会 '叮'一声提醒用户) 下载软件。小明一直坐在电脑前什么事也不做，等待软件下载完成。
阻塞：小明(调用者) 等待电脑下载完成，什么事也不做（当前进程挂起）。
异步：有提醒功能的 chrome，下载完成的时候会提醒小明。（调用结果返回时会通知进程）
总结：虽然调用结果返回会通知进程，但是调用结果返回前，当前进程挂起。所以同样效率低

这里我们可以看出，同步和异步是一种 消息通知机制， 是相对于被调用者而言的。

同步:

A调用B，B处理直到获得结果，才返回给A。
需要调用者一直等待和确认调用结果是否返回， 然后继续往下执行。

异步:

A调用B，B直接返回。无需等待结果，B通过状态，通知等来通知A或回调函数来处理。
调用结果返回时， 会以消息或回调的方式通知调用者。

3.同步非阻塞

小明使用 没有提醒功能的chrome 下载软件，然后去做其他事情，时不时的过来确认下软件是否下载完成（轮询？）。小明做其他事情的效率不高。
非阻塞： 小明 (调用者) 执行需要等待的任务后，去做其他事情。
同步：没有提醒功能的 chrome(被调用者）需要 小明(调用者) 确认是否完成任务。
总结：调用结果返回前不会阻塞当前进程，当前进程可以去做其他事情，但是需要通过轮询来确认调用结果是否返回，耗cpu性能，效率会比 1，2 高点。但是还不够高

4.异步非阻塞

小明使用 有提醒功能的chrome 下载软件， 然后去做其他事，当软件下载完成的时候会通知小明。
非阻塞： 小明 (调用者) 执行需要等待的任务后，去做其他事情。
异步： 有通知功能的 chrome (被调用者) 下载完成后会通知 小明(调用者)。
总结：调用结果返回前当前进程可以继续做其他事情，函数调用完成后会以回调或者消息的方式通知进程。效率最高。

这里我们可以看出 阻塞非阻塞 描述的是进程等待调用结果返回前的状态， 是相对于调用者而言的。

阻塞：

A调用B，A被挂起直到B返回结果给A，A继续执行。
调用结果返回前，当前进程挂起不能够处理其他任务，一直等待调用结果返回。

非阻塞：

A调用B，A不会被挂起，A可以执行其他操作。
调用结果返回前，当前进程不挂起， 可以去处理其他任务。

所以我们要区分开同步异步阻塞非阻塞，同步异步说的是被调用者结果返回时通知进程的一种通知机制，阻塞非阻塞说的是调用结果返回前进程的状态，是挂起还是继续处理其他任务。

python 的 tornado 框架就是一种异步非阻塞框架。